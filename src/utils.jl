small_angle_distance = ((ra_a, dec_a), (ra_b, dec_b)) -> sqrt(((ra_a-ra_b)*cos(deg2rad(dec_a)))^2 + (dec_a-dec_b)^2) # units of degrees

function deg2arcsec(deg::Float64)
    return deg * 3600.0
end

function arcsec2deg(arcsec::Float64)
    return arcsec / 3600.0
end

function all_header_keywords_match(ha, hb, kws)
    for kw in kws
        if ha[kw] != hb[kw]
            return false
        end
    end
    return true
end

function pretty_print_toml(dict::OrderedDict{String, Any})
    io = IOBuffer()
    TOML.print(io, dict)
    toml_str = String(take!(io))

    pattern = r"=\s*\[(.*?)\]"s
    replacements = []

    for m in eachmatch(pattern, toml_str)
        arr_content = m.captures[1]
        entries = split(arr_content, ",")
        formatted = "= [\n" * join(["    " * strip(e) for e in entries if !isempty(strip(e))], ",\n") * "\n]"
        push!(replacements, (m.match, formatted))
    end

    toml_str = reduce(replacements, init=toml_str) do current_str, (old, new)
        replace(current_str, old => new)
    end

    toml_str = replace(toml_str, r"\n(?=\w+\s*=)" => "\n\n")

    header_str = "# auto-generated by AIR.pretty_print_toml\n\n"

    return header_str*toml_str
end

function framelist_to_cube(frames::Vector{<:AstroImage})
    frames = [f.data for f in frames]
    stack = cat(frames..., dims=3)
    return stack
end

function match_keys(frames, keylist)
    matched_dict = Dict{Any, Vector{AstroImage}}()
    for f in frames
        key = [f[k] for k in keylist]
        if !(key in keys(matched_dict))
            matched_dict[key] = AstroImage[]
            push!(matched_dict[key], f)
        else
            push!(matched_dict[key], f)
        end
    end
    return matched_dict
end

function make_and_clear(folder_path, glob_pattern)
    if !isdir(folder_path)
        mkpath(folder_path)
    else
        for fn in Glob.glob(glob_pattern, folder_path)
            @info "Removing" fn
            rm(fn)
        end
    end
end

function make_circle_mask(img_size::Tuple{Int, Int}, radius::Int; center::Union{Tuple{Int, Int}, Nothing}=nothing)
    # image size
    h, w = img_size

    # If center is not provided, calculate it
    if center === nothing
        center_y = h รท 2 + 1
        center_x = w รท 2 + 1
    else
        center_y, center_x = center
    end

    # Create the mask
    mask = BitMatrix(undef, h, w)
    for i in 1:h
        for j in 1:w
            # Distance from the center
            dist = sqrt((i - center_y)^2 + (j - center_x)^2)
            mask[i, j] = dist <= radius
        end
    end

    return mask
end

function image_is_larger(a::AstroImage, b::AstroImage)
    return all(map(>, size(a), size(b)))
end

function crop(img::AbstractArray, crop_size::Tuple{Int,Int}; center=nothing)
    h, w = size(img)
    crop_h, crop_w = crop_size

    if h==crop_h && w==crop_w
        return img  # No cropping needed, return the original image
    end

    if center === nothing
        center_row = Int(round(h/2))
        center_col = Int(round(w/2))
    else
        center_row, center_col = center
    end

    start_row = center_row - div(crop_h, 2)
    end_row   = start_row + crop_h - 1
    start_col = center_col - div(crop_w, 2)
    end_col   = start_col + crop_w - 1

    if start_row < 1 || start_col < 1 || end_row > h || end_col > w
        error("Crop would go out of bounds: img size $(size(img)), crop from ($(start_row),$(start_col)) to ($(end_row),$(end_col))")
    end

    img[start_row:end_row, start_col:end_col]
end