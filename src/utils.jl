
small_angle_distance((ra_a, dec_a), (ra_b, dec_b)) = sqrt(((ra_a-ra_b)*cos(deg2rad(dec_a)))^2 + (dec_a-dec_b)^2) # units of degrees
image_is_larger(a::AbstractArray, b::AbstractArray) = all(map(>, size(a), size(b)))
deg2arcsec(deg::Real) = deg * 3600.0
arcsec2deg(arcsec::Real) = arcsec / 3600.0
pixel_center_coordinates = x ->  x + 0.5
cartesian_coordinates = x -> x - 0.5
remove_nan! = x -> @. x[~isfinite(x)] = 0.0

function all_header_keywords_match(ha, hb, kws)
    for kw in kws
        if ha[kw] != hb[kw]
            return false
        end
    end
    return true
end

function pretty_print_toml(dict::OrderedDict{String, Any})
    io = IOBuffer()
    TOML.print(io, dict)
    toml_str = String(take!(io))

    pattern = r"=\s*\[(.*?)\]"s
    replacements = []

    for m in eachmatch(pattern, toml_str)
        arr_content = m.captures[1]
        entries = split(arr_content, ",")
        formatted = "= [\n" * join(["    " * strip(e) for e in entries if !isempty(strip(e))], ",\n") * "\n]"
        push!(replacements, (m.match, formatted))
    end

    toml_str = reduce(replacements, init=toml_str) do current_str, (old, new)
        replace(current_str, old => new)
    end

    toml_str = replace(toml_str, r"\n(?=\w+\s*=)" => "\n\n")

    header_str = "# auto-generated by AIR.pretty_print_toml\n\n"

    return header_str*toml_str
end

function framelist_to_cube(frames::Vector{<:AstroImage})
    frames = [f.data for f in frames]
    stack = cat(frames..., dims=3)
    return stack
end

function match_keys(frames, keylist)
    matched_dict = Dict{Any, Vector{AstroImage}}()
    for f in frames
        # create a new key based on the values of the keys in the keylist
        key = [f[k] for k in keylist]
        if !(key in keys(matched_dict))
            matched_dict[key] = AstroImage[]
            push!(matched_dict[key], f)
        else
            push!(matched_dict[key], f)
        end
    end
    return matched_dict
end

function make_and_clear(folder_path, glob_pattern)
    if !isdir(folder_path)
        mkpath(folder_path)
    else
        for fn in Glob.glob(glob_pattern, folder_path)
            rm(fn)
        end
    end
end

function make_circle_mask(img_size::Tuple{Int, Int}, radius::Int; center::Union{Tuple{Int, Int}, Nothing}=nothing)

    sy, sx = img_size

    if center === nothing
        center_y = sy / 2.0 + 0.5
        center_x = sx / 2.0 + 0.5
    else
        center_y, center_x = center
    end

    mask = BitMatrix(undef, sy, sx)
    for i in 1:sy
        for j in 1:sx
            dist = sqrt((i - center_y)^2 + (j - center_x)^2)
            mask[i, j] = dist <= radius
        end
    end

    return mask
end

function make_annulus_mask(img_size::Tuple{Int, Int}, inner_radius::Int, outer_radius::Int; center::Union{Tuple{Int, Int}, Nothing}=nothing)
    # image size
    sy, sx = img_size

    # If center is not provided, calculate it
    if center === nothing
        center_y = sy / 2.0 + 0.5
        center_x = sx / 2.0 + 0.5
    else
        center_y, center_x = center
    end

    mask = BitMatrix(undef, sy, sx)
    for i in 1:sy
        for j in 1:sx
            dist = sqrt((i - center_y)^2 + (j - center_x)^2)
            mask[i, j] = inner_radius <= dist <= outer_radius
        end
    end

    return mask
end

function make_sigma_clip_mask(image_data::AbstractMatrix, n_sigma::Real = 9.0)
    if isempty(image_data)
        return BitMatrix(zeros(Bool, 0, 0))
    end

    mean_val = median(image_data)
    std_dev = std(image_data)
    threshold = mean_val + (n_sigma * std_dev)
    mask = image_data .> threshold

    return mask
end


"""
    crop(img::AbstractArray, crop_size::Tuple{Int,Int}; center=nothing)

    Crop an image to a specified size around a center point.
    Note that there is a call to "round" in the function, which means that we round to the closest integer "center"
    If the center is not specified, it will be set to the center of the image.

    Returns the cropped image, and the offsets in y and x direction
    add offset to go from cropped to original coordinate system
    subtract offset to go from original to cropped coordinate system
"""
function crop(img::AbstractArray, crop_size::Tuple{Int,Int}; center=nothing)
    h, w = size(img)
    crop_h, crop_w = crop_size

    if h==crop_h && w==crop_w
        @info "No cropping needed, input size equals output size!"
        return img, 0.0, 0.0  # No cropping needed, return the original image
    end

    # both not even or both not odd
    if !(iseven(h) && iseven(crop_h) || isodd(h) && isodd(crop_h))
        @debug "Input and output height are not both even or both odd, final image will offset"
    end

    # both not even or both not odd
    if !(iseven(w) && iseven(crop_w) || isodd(w) && isodd(crop_w))
        @debug "Input and output width are not both even or both odd, final image will offset"
    end

    if center === nothing
        image_center_y = (h/2)+1
        image_center_x = (w/2)+1
    else
        image_center_y, image_center_x = center
    end

    # round to guarantee that this works
    start_row = round(Int, image_center_y - crop_h/2)
    end_row   = round(Int, start_row + crop_h - 1)
    start_col = round(Int, image_center_x - crop_w/2)
    end_col   = round(Int, start_col + crop_w - 1)

    if start_row < 1 || start_col < 1 || end_row > h || end_col > w
        error("Crop would go out of bounds: img size $(size(img)), $(image_center_y), $(image_center_x), crop_size $(crop_size)")
    end

    # add this number to go from cropped to original coordinate system
    # subtract this number to go from original to cropped coordinate system
    offset_x = start_col - 1
    offset_y = start_row - 1

    return img[start_row:end_row, start_col:end_col], offset_y, offset_x
end

function subpixel_crop(img::AbstractArray, crop_size::Tuple{Int,Int}, center::Tuple{Float64,Float64})
    h, w = size(img)
    crop_h, crop_w = crop_size

    if h==crop_h && w==crop_w
        @info "No cropping needed, input size equals output size!"
        return img  # No cropping needed, return the original image
    end

    cy, cx = center

    image_center_y = (h/2)+1
    image_center_x = (w/2)+1

    # this madness is to compensate for the truncation that we do in the end
    if iseven(h)
        if iseven(crop_h)
            offset_x = 0.5
        else
            offset_x = 1.0
        end
    else
        if iseven(crop_h)
            offset_x = 1.0
        else
            offset_x = 0.5
        end
    end

    if iseven(w)
        if iseven(crop_w)
            offset_y = 0.5
        else
            offset_y = 1.0
        end
    else
        if iseven(crop_w)
            offset_y = 1.0
        else
            offset_y = 0.5
        end
    end

    tx = cx - image_center_x 
    ty = cy - image_center_y

    warped_img = warp(img, Translation(ty+offset_y, tx+offset_x), axes(img))

    start_row = trunc(Int, image_center_y - crop_h/2)
    end_row = start_row + crop_h - 1
    start_col = trunc(Int, image_center_x - crop_w/2)
    end_col = start_col + crop_w - 1

    if start_row < 1 || start_col < 1 || end_row > h || end_col > w
        error("Crop would go out of bounds: img size $(size(img)), $(image_center_y), $(image_center_x), crop_size $(crop_size)")
    end

    # add this number to go from cropped to original coordinate system
    # subtract this number to go from original to cropped coordinate system
    ox = start_col - 1 + tx + offset_x
    oy = start_row - 1 + ty + offset_y
    
    return warped_img[start_row:end_row, start_col:end_col], oy, ox
end

function subpixel_crop(img::AstroImage, crop_size::Tuple{Int,Int}, center::Tuple{Float64,Float64})
    cropped, oy, ox = subpixel_crop(img.data, crop_size, center)
    return AstroImage(cropped, img.header), oy, ox
end


"""
    measure_background(frame::AstroImage; mask_radius=200)

Measure the background level in a frame while masking out the PSF.
Returns the median background level from an annular region.
"""
function measure_background(frame::AstroImage; mask_radius=200)
    data = frame.data
    rows, cols = size(data)
    
    # Find the center of the PSF (brightest pixel)
    _, center_idx = findmax(data)
    cy, cx = Tuple(center_idx)
    
    # Create mask to exclude PSF and edges
    mask = trues(size(data))
    
    # Mask out the PSF (circular region around center)
    for i in 1:rows, j in 1:cols
        r = sqrt((i - cy)^2 + (j - cx)^2)
        if r < mask_radius
            mask[i, j] = false
        end
    end
    
    # Extract background pixels
    background_pixels = data[mask]
    
    if length(background_pixels) == 0
        @warn "No background pixels found, returning 0"
        return 0.0
    end
    
    # Return median background level
    return median(background_pixels)
end

function make_frametable(frames, table_filename; fields=String[])

    fields_dict = OrderedDict{String,Int}("FILENAME" => 18,
                                          "OBJECT" => 16,
                                          "TARGNAME" => 16,
                                          "RA" => 12,
                                          "DEC" => 12,
                                          "CAMNAME" => 8,
                                          "DATE-OBS" => 10,
                                          "UTC" => 11,
                                          "ITIME" => 8,
                                          "COADDS" => 8,
                                          "FILTER" => 20,
                                          "FWONAME" => 10,
                                          "FWINAME" => 10,
                                          "GRSNAME" => 8,
                                          "EL" => 6,
                                          "AZ" => 6,
                                          "PARANG" => 6,
                                          "ROTMODE" => 16,
                                          "INSTANG" => 8,
                                          "PARANTEL" => 8,
                                          "SLITNAME" => 10,
                                          "NAXIS1" => 6,
                                          "NAXIS2" => 6)

    if fields == String[]
        fields = keys(fields_dict)
    end

    printed_fields = OrderedDict{String,Int}()
    for field in fields
        if field in keys(fields_dict)
            printed_fields[field] = fields_dict[field]
        end
    end

    @info "Writing frames table to" table_filename

    open(table_filename, "w") do io
        # print header
        for (i, (f,l)) in enumerate(pairs(printed_fields))
            @printf(io, "%-*s ", l, f)
            if i != length(fields)
                @printf(io, "| ")
            end
        end
        @printf(io, "\n")

        # print info for each frame
        for frame in frames
            for (i, (f,l)) in enumerate(pairs(printed_fields))
                if !haskey(frame, f)
                    @printf(io, "%-*s ", l, "")
                else
                    @printf(io, "%-*s ", l, frame[f])
                end

                if i != length(fields)
                    @printf(io, "| ")
                end

            end
            @printf(io, "\n")
        end

    end
end

function argquantile(img::AbstractArray, quant::Float64)
    val = quantile(vec(img), quant)
	_, inds = findmin(abs.(img .- val))
    return inds.I
end