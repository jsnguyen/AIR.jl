module AIR

using Logging
using LoggingExtras

using TOML
using OrderedCollections
using Printf

using AstroImages
using SkyCoords
using AstroAngles
using Plots
using Statistics
using ImageFiltering

export pretty_print_toml, deg2arcsec, arcsec2deg, all_header_keywords_match, load_obslog, load_frames, framelist_to_cube, match_keys, crop, make_sigma_clip_mask, make_masters, autolog, NIRC2_bad_pixel_mask, find_matching_master, find_closest_flat, find_closest_dark

const NIRC2_bad_pixel_mask = Bool.(load("masks/bad_pixel_mask_20230101.fits").data)

function deg2arcsec(deg::Float64)
    return deg * 3600.0
end

function arcsec2deg(arcsec::Float64)
    return arcsec / 3600.0
end

function all_header_keywords_match(ha, hb, kws)
    for kw in kws
        if ha[kw] != hb[kw]
            return false
        end
    end

    return true
end

function pretty_print_toml(dict::OrderedDict{String, Any})
    io = IOBuffer()
    TOML.print(io, dict)
    toml_str = String(take!(io))

    pattern = r"=\s*\[(.*?)\]"s
    replacements = []

    for m in eachmatch(pattern, toml_str)
        arr_content = m.captures[1]
        entries = split(arr_content, ",")
        formatted = "= [\n" * join(["    " * strip(e) for e in entries if !isempty(strip(e))], ",\n") * "\n]"
        push!(replacements, (m.match, formatted))
    end

    toml_str = reduce(replacements, init=toml_str) do current_str, (old, new)
        replace(current_str, old => new)
    end

    toml_str = replace(toml_str, r"\n(?=\w+\s*=)" => "\n\n")

    header_str = "# Obslog auto-generated by AIR.pretty_print_toml\n\n"

    return header_str*toml_str
end

function load_obslog(obslog_filename::String)
    obslog = open(obslog_filename, "r") do file
        TOML.parse(file)
    end

    for key in keys(obslog)
        if key == "data_folder"
            continue
        else
            obslog[key] = [joinpath(obslog["data_folder"], "raw", fn) for fn in obslog[key]]
        end
    end

    return obslog
end

function load_frames(obslog, key)

    frames = AstroImage[]

    if !haskey(obslog, key)
        return frames
    end

    for fn in obslog[key]
        push!(frames, load(fn))
    end

    return frames
end

function framelist_to_cube(frames::Vector{AstroImage})
    frames = [f.data for f in frames]
    stack = cat(frames..., dims=3)
    return stack
end

function match_keys(frames, keylist)
    matched_dict = Dict{Any, Vector{AstroImage}}()
    for f in frames
        key = [f[k] for k in keylist]
        if !(key in keys(matched_dict))
            matched_dict[key] = AstroImage[]
            push!(matched_dict[key], f)
        else
            push!(matched_dict[key], f)
        end
    end
    return matched_dict
end

function crop(img::AbstractArray, crop_size::Tuple{Int,Int}; center=nothing)
    h, w = size(img)
    crop_h, crop_w = crop_size

    if center === nothing
        center_row = Int(round(h/2))
        center_col = Int(round(w/2))
    else
        center_row, center_col = center
    end

    start_row = center_row - div(crop_h, 2)
    end_row   = start_row + crop_h - 1
    start_col = center_col - div(crop_w, 2)
    end_col   = start_col + crop_w - 1

    if start_row < 1 || start_col < 1 || end_row > h || end_col > w
        error("Crop would go out of bounds: img size $(size(img)), crop from ($(start_row),$(start_col)) to ($(end_row),$(end_col))")
    end

    img[start_row:end_row, start_col:end_col]
end


function make_sigma_clip_mask(image_data::AbstractMatrix, n_sigma::Real = 9.0)
    if isempty(image_data)
        return BitMatrix(zeros(Bool, 0, 0))
    end

    mean_val = median(image_data)
    std_dev = std(image_data)
    threshold = mean_val + (n_sigma * std_dev)
    mask = image_data .> threshold

    return mask
end

function make_masters(frames, keylist; n_sigma::Float64=6.0, median_size::Int64=5, method::Function=median)

    frame_dict = match_keys(frames, keylist)

    for key in keys(frame_dict)
        @printf "key -> %s, count -> %d\n " key length(frame_dict[key])
    end

    master_frames = Dict{Any, AstroImage}()
    for key in keys(frame_dict)

        # applies method (mean, median) to frame list
        stack = framelist_to_cube(frame_dict[key])
        method_stack = method(stack, dims=3) |> x -> dropdims(x, dims=3)
        mf = AstroImage(method_stack)

        # take each frame, make a sigma clip mask, and then combine them or-wise
        masks = [make_sigma_clip_mask(frame.data, n_sigma) for frame in frame_dict[key]]
        sigma_clip_mask = reduce(.|, masks)

        # crop the original bad pixel mask to the size of the median frame
        bad_pixel_mask = copy(NIRC2_bad_pixel_mask)
        if size(bad_pixel_mask) != size(mf)
            bad_pixel_mask = crop(NIRC2_bad_pixel_mask, size(mf))
        end

        # combine masks
        mask = bad_pixel_mask .| sigma_clip_mask

        # make the median frame to do pixel replacement
        # not super efficient, but it works
        median_mf = mapwindow(median, mf.data, (median_size, median_size))

        # finally, assign the median values to the masked pixels
        mf.data[mask] .= median_mf[mask]

        # repopulate the header with the key values so we can find the keys later
        for (i,k) in enumerate(keylist)
            mf[k] = key[i]
        end

        mf["NFRAMES"] = length(frame_dict[key])
        mf["NSIGMASK"] = n_sigma
        mf["MEDSIZE"] =  median_size
        mf["NPIXMASK"] = sum(mask)
        mf["MAMEDIAN"] = median(mf.data[.!mask])
        mf["MAMEAN"] = mean(mf.data[.!mask])
        mf["MASTD"] = std(mf.data[.!mask])

        master_frames[key] = mf
    end

    return master_frames

end

function autolog(f, log_filename)

    if splitext(log_filename)[end] != ".log"
        error("Logfile must have a .log extension")
    end

    open(log_filename, "w") do logfile
        console_logger = ConsoleLogger(stdout)
        file_logger = SimpleLogger(logfile)
        demux_logger = TeeLogger(console_logger, file_logger)
        global_logger(demux_logger)
        f()
    end
end

function find_matching_master(frame, masters, keylist)

    matches = [all_header_keywords_match(frame, m, keylist) for m in masters]

    if any(matches)
        ind = findfirst(matches)
        matched = masters[ind]
    else
        return nothing
    end

    return matched

end

function image_is_larger(a::AstroImage, b::AstroImage)
    return all(map(>, size(a), size(b)))
end

"""
Guarantees finding a flat frame that matches at least the FILTER. Frame should be cropped as well.
"""
function find_closest_flat(frame, master_flats, flats_keylist=["FILTER"])
    matched_flat = find_matching_master(frame, master_flats, flats_keylist)

    if matched_flat !== nothing
        if (size(matched_flat) != size(frame))
            if image_is_larger(matched_flat, frame)
                cropped_flat = crop(matched_flat.data, size(frame))
                matched_flat = AstroImage(cropped_flat, matched_flat.header)
            else
                @warn "Flat frame is smaller than the target frame, not cropping: $(frame["FILENAME"])"
                return nothing
            end
        end
    else
        @warn "No matching flat found for $(frame["FILENAME"])"
    end

    return matched_flat

end

"""
Guarantees finding a dark frame that matches at least the ITIME. Frame should be cropped as well.

# Arguments
- `frame`: The frame for which we want to find a matching dark.
- `master_darks`: A list of master dark frames.
- `ranked_darks_keylist`: A list of keylists in order of preference for matching dark frames. Each keylist is a list of header keywords that should match. At minimum we want to match the ITIME.
"""
function find_closest_dark(frame, master_darks, ranked_darks_keylist = [["NAXIS1", "NAXIS2", "ITIME", "COADDS"], ["NAXIS1", "NAXIS2", "ITIME"], ["ITIME"]])

    matched_dark = nothing
    for (i,keylist) in enumerate(ranked_darks_keylist)
        matched_dark = find_matching_master(frame, master_darks, keylist)
        if matched_dark !== nothing

            # for the 2nd and 3rd case, rescale by coadds
            if (i==2) || (i==3)
                @warn "Rescaling dark frame by COADDS $(matched_dark["COADDS"]) -> $(frame["COADDS"])"
                matched_dark = matched_dark ./ matched_dark["COADDS"] .* frame["COADDS"]
            end

            if i == 3
                if  (size(matched_dark) != size(frame))
                    if image_is_larger(matched_dark, frame)
                        cropped_dark = crop(matched_dark.data, size(frame))
                        matched_dark= AstroImage(cropped_dark, matched_dark.header)
                    else
                        @warn "Dark frame is smaller than the target frame, not cropping: $(frame["FILENAME"])"
                        return nothing
                    end
                end
            end

            break
        end
    end

    if matched_dark === nothing
        @warn "No matching dark found"
    end

    return matched_dark

end

end
