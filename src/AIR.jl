module AIR

using Logging
using LoggingExtras

using Glob
using TOML
using OrderedCollections
using Printf
using Dates

using AstroImages
using SkyCoords
using AstroAngles
using Plots
using Statistics
using ImageFiltering
using LsqFit
using CoordinateTransformations
using AstroLib
using LACosmic

const observatory_lat = +19.82525
const observatory_lon = -155.468889

export small_angle_distance, pretty_print_toml, deg2arcsec, arcsec2deg, all_header_keywords_match, load_obslog, load_frames, framelist_to_cube, match_keys, crop, make_sigma_clip_mask, make_masters, autolog, NIRC2_bad_pixel_mask, find_matching_master, find_closest_flat, find_closest_dark, get_NIRC2_gain, make_and_clear, gaussian2d_fit, gaussian2d_fixedwidth_fit, make_circle_mask, calculate_north_angle, par_angle, load_sequences

small_angle_distance = ((ra_a, dec_a), (ra_b, dec_b)) -> sqrt(((ra_a-ra_b)*cos(deg2rad(dec_a)))^2 + (dec_a-dec_b)^2) # units of degrees

const _mask_dir = joinpath(@__DIR__, "..", "masks")
const NIRC2_bad_pixel_mask = begin
    maskfile = joinpath(_mask_dir, "bad_pixel_mask_20230101.fits")
    img = load(maskfile)            # from AstroImages or FITSIO
    Bool.(img.data)                 # convert to Bool matrix
end

function deg2arcsec(deg::Float64)
    return deg * 3600.0
end

function arcsec2deg(arcsec::Float64)
    return arcsec / 3600.0
end

function all_header_keywords_match(ha, hb, kws)
    for kw in kws
        if ha[kw] != hb[kw]
            return false
        end
    end

    return true
end

function pretty_print_toml(dict::OrderedDict{String, Any})
    io = IOBuffer()
    TOML.print(io, dict)
    toml_str = String(take!(io))

    pattern = r"=\s*\[(.*?)\]"s
    replacements = []

    for m in eachmatch(pattern, toml_str)
        arr_content = m.captures[1]
        entries = split(arr_content, ",")
        formatted = "= [\n" * join(["    " * strip(e) for e in entries if !isempty(strip(e))], ",\n") * "\n]"
        push!(replacements, (m.match, formatted))
    end

    toml_str = reduce(replacements, init=toml_str) do current_str, (old, new)
        replace(current_str, old => new)
    end

    toml_str = replace(toml_str, r"\n(?=\w+\s*=)" => "\n\n")

    header_str = "# auto-generated by AIR.pretty_print_toml\n\n"

    return header_str*toml_str
end

function load_obslog(obslog_filename::String)
    obslog = open(obslog_filename, "r") do file
        TOML.parse(file)
    end
    return obslog
end

function load_frames(obslog, key; rejects::Vector{String}=String[])

    frames = AstroImage[]

    if !haskey(obslog, key)
        return frames
    end

    for fn in obslog[key]
        if fn in rejects
            continue
        end
            push!(frames, Float64.(load(joinpath(obslog["data_folder"], obslog["subfolder"], fn))))
    end

    return frames
end

function framelist_to_cube(frames::Vector{AstroImage})
    frames = [f.data for f in frames]
    stack = cat(frames..., dims=3)
    return stack
end

function match_keys(frames, keylist)
    matched_dict = Dict{Any, Vector{AstroImage}}()
    for f in frames
        key = [f[k] for k in keylist]
        if !(key in keys(matched_dict))
            matched_dict[key] = AstroImage[]
            push!(matched_dict[key], f)
        else
            push!(matched_dict[key], f)
        end
    end
    return matched_dict
end

function crop(img::AbstractArray, crop_size::Tuple{Int,Int}; center=nothing)
    h, w = size(img)
    crop_h, crop_w = crop_size

    if h==crop_h && w==crop_w
        return img  # No cropping needed, return the original image
    end

    if center === nothing
        center_row = Int(round(h/2))
        center_col = Int(round(w/2))
    else
        center_row, center_col = center
    end

    start_row = center_row - div(crop_h, 2)
    end_row   = start_row + crop_h - 1
    start_col = center_col - div(crop_w, 2)
    end_col   = start_col + crop_w - 1

    if start_row < 1 || start_col < 1 || end_row > h || end_col > w
        error("Crop would go out of bounds: img size $(size(img)), crop from ($(start_row),$(start_col)) to ($(end_row),$(end_col))")
    end

    img[start_row:end_row, start_col:end_col]
end


function make_sigma_clip_mask(image_data::AbstractMatrix, n_sigma::Real = 9.0)
    if isempty(image_data)
        return BitMatrix(zeros(Bool, 0, 0))
    end

    mean_val = median(image_data)
    std_dev = std(image_data)
    threshold = mean_val + (n_sigma * std_dev)
    mask = image_data .> threshold

    return mask
end

function make_masters(frames, keylist; n_sigma::Float64=6.0, median_size::Int64=5, method::Function=median)

    frame_dict = match_keys(frames, keylist)

    for key in keys(frame_dict)
        @printf "key -> %s, count -> %d\n " key length(frame_dict[key])
    end

    master_frames = Dict{Any, AstroImage}()
    master_frames_masks = Dict{Any, BitMatrix}()
    for key in keys(frame_dict)

        # applies method (mean, median) to frame list
        stack = framelist_to_cube(frame_dict[key])
        method_stack = method(stack, dims=3) |> x -> dropdims(x, dims=3)
        mf = AstroImage(method_stack)

        # take each frame, make a sigma clip mask, and then combine them or-wise
        masks = [make_sigma_clip_mask(frame.data, n_sigma) for frame in frame_dict[key]]
        sigma_clip_mask = reduce(.|, masks)

        # crop the original bad pixel mask to the size of the median frame
        bad_pixel_mask = copy(NIRC2_bad_pixel_mask)
        if size(bad_pixel_mask) != size(mf)
            bad_pixel_mask = crop(NIRC2_bad_pixel_mask, size(mf))
        end

        # combine masks
        mask = bad_pixel_mask .| sigma_clip_mask

        # make the median frame to do pixel replacement
        # not super efficient, but it works
        median_mf = mapwindow(median, mf.data, (median_size, median_size))

        # finally, assign the median values to the masked pixels
        mf.data[mask] .= median_mf[mask]

        # repopulate the header with the key values so we can find the keys later
        for (i,k) in enumerate(keylist)
            mf[k] = key[i]
        end

        mf["NFRAMES"] = length(frame_dict[key])
        mf["NSIGMASK"] = n_sigma
        mf["MEDSIZE"] =  median_size
        mf["NPIXMASK"] = sum(mask)
        mf["MAMEDIAN"] = median(mf.data[.!mask])
        mf["MAMEAN"] = mean(mf.data[.!mask])
        mf["MASTD"] = std(mf.data[.!mask])

        master_frames[key] = mf
        master_frames_masks[key] = mask
    end

    return master_frames, master_frames_masks

end

function autolog(f, log_filename)

    if splitext(log_filename)[end] != ".log"
        error("Logfile must have a .log extension")
    end

    open(log_filename, "w") do logfile
        console_logger = ConsoleLogger(stdout)
        file_logger = SimpleLogger(logfile)
        demux_logger = TeeLogger(console_logger, file_logger)
        global_logger(demux_logger)
        f()
    end
end

function find_matching_master(frame, masters, keylist)

    matches = [all_header_keywords_match(frame, m, keylist) for m in masters]

    if any(matches)
        ind = findfirst(matches)
        matched = masters[ind]
    else
        return nothing
    end

    return matched

end

function image_is_larger(a::AstroImage, b::AstroImage)
    return all(map(>, size(a), size(b)))
end

"""
Guarantees finding a flat frame that matches at least the FILTER. Frame should be cropped as well.
"""
function find_closest_flat(frame, master_flats, flats_keylist=["FILTER"])
    matched_flat = find_matching_master(frame, master_flats, flats_keylist)

    if matched_flat !== nothing
        if (size(matched_flat) != size(frame))
            if image_is_larger(matched_flat, frame)
                cropped_flat = crop(matched_flat.data, size(frame))
                matched_flat = AstroImage(cropped_flat, matched_flat.header)
            else
                @warn "Flat frame is smaller than the target frame, not cropping: $(frame["FILENAME"])"
                return nothing
            end
        end
    else
        @warn "No matching flat found for $(frame["FILENAME"])"
    end

    return matched_flat

end

"""
Guarantees finding a dark frame that matches at least the ITIME. Frame should be cropped as well.

# Arguments
- `frame`: The frame for which we want to find a matching dark.
- `master_darks`: A list of master dark frames.
- `ranked_darks_keylist`: A list of keylists in order of preference for matching dark frames. Each keylist is a list of header keywords that should match. At minimum we want to match the ITIME.
"""
function find_closest_dark(frame, master_darks, ranked_darks_keylist = [["NAXIS1", "NAXIS2", "ITIME", "COADDS"], ["NAXIS1", "NAXIS2", "ITIME"], ["ITIME"]])

    matched_dark = nothing
    for (i,keylist) in enumerate(ranked_darks_keylist)
        matched_dark = find_matching_master(frame, master_darks, keylist)
        if matched_dark !== nothing

            # for the 2nd and 3rd case, rescale by coadds
            if (i==2) || (i==3)
                @warn "Rescaling dark frame by COADDS $(matched_dark["COADDS"]) -> $(frame["COADDS"])"
                matched_dark = matched_dark ./ matched_dark["COADDS"] .* frame["COADDS"]
            end

            if i == 3
                if  (size(matched_dark) != size(frame))
                    if image_is_larger(matched_dark, frame)
                        cropped_dark = crop(matched_dark.data, size(frame))
                        matched_dark= AstroImage(cropped_dark, matched_dark.header)
                    else
                        @warn "Dark frame is smaller than the target frame, not cropping: $(frame["FILENAME"])"
                        return nothing
                    end
                end
            end

            break
        end
    end

    if matched_dark === nothing
        @warn "No matching dark found"
    end

    return matched_dark

end

function get_NIRC2_gain(date_obs)
    d = Date(date_obs, dateformat"y-m-d")
    gain_date = Date(2023, 11, 20)

    if d < gain_date
        return 4.0  # pre-2023 gain
    else
        return 8.0  # post-2023 gain
    end

end

function make_and_clear(folder_path, glob_pattern)
    if !isdir(folder_path)
        mkpath(folder_path)
    else
        for fn in Glob.glob(glob_pattern, folder_path)
            @info "Removing" fn
            rm(fn)
        end
    end
end

function gaussian2d_fit(data::Matrix{Float64}, initial_guess::Vector{Float64})
    # Define the 2D Gaussian model
    model(coords, p) = p[1] .* exp.(-((coords[:,1] .- p[2] .- 0.5).^2 ./ (2 * p[4]^2) + (coords[:, 2] .- p[3] .- 0.5).^2 ./ (2 * p[5]^2))) .+ p[6]

    # Create the coordinate grid
    rows, cols = size(data)

    x = repeat(1.0:cols, inner=rows) # x-coordinates repeated for each row
    y = repeat(1.0:rows, outer=cols) # y-coordinates repeated for each column
    coords = hcat(x, y)  # shape is (2, rows*cols)

    # Perform the fit
    fit = curve_fit(model, coords, vec(data), initial_guess)

    return fit.param
end

function gaussian2d_fixedwidth_fit(data::Matrix{Float64}, initial_guess::Vector{Float64}, width::Float64)
    # Define the 2D Gaussian model
    # 1-based indexing here means we have to subtract 0.5 from the x and y coordinates to center the gaussian on the pixel grid
    model(coords, p) = p[1] .* exp.(-((coords[:,1] .- p[2] .- 0.5).^2 ./ (2 * width^2) + (coords[:, 2] .- p[3] .- 0.5).^2 ./ (2 * width^2))) .+ p[4]

    # Create the coordinate grid
    rows, cols = size(data)

    x = repeat(1.0:cols, inner=rows) # x-coordinates repeated for each row
    y = repeat(1.0:rows, outer=cols) # y-coordinates repeated for each column
    coords = hcat(x, y)  # shape is (2, rows*cols)

    # Perform the fit
    fit = curve_fit(model, coords, vec(data), initial_guess)

    return fit.param
end

function make_circle_mask(img_size::Tuple{Int, Int}, radius::Int; center::Union{Tuple{Int, Int}, Nothing}=nothing)
    # image size
    h, w = img_size

    # If center is not provided, calculate it
    if center === nothing
        center_y = h ÷ 2 + 1
        center_x = w ÷ 2 + 1
    else
        center_y, center_x = center
    end

    # Create the mask
    mask = BitMatrix(undef, h, w)
    for i in 1:h
        for j in 1:w
            # Distance from the center
            dist = sqrt((i - center_y)^2 + (j - center_x)^2)
            mask[i, j] = dist <= radius
        end
    end

    return mask
end


"""
Calculate and return the starting angle, angular smear, and mean angle to north
of an image from NIRC2 narrow cam, given its headers.

The calculation is adapted from pyKLIP.
"""

float_or_parse_hexages(num::Number) = num
float_or_parse_hexages(str::AbstractString) = AstroLib.ten(str)

function calculate_north_angle(headers)
    zp_offset = -0.262 # From Service et al 2016
    rotator_mode = headers["ROTMODE"]
    rotator_position = headers["ROTPOSN"] # Degrees
    instrument_angle = headers["INSTANGL"] # Degrees

    rotator_mode = "vertical angle"

    pa_deg = 0.0
    if rotator_mode == "vertical angle"
        if haskey(headers, "PARANTEL")
            parang = headers["PARANTEL"]
        else
            parang = headers["PARANG"]
        end
        pa_deg = parang + rotator_position - instrument_angle + zp_offset
    elseif rotator_mode == "position angle"
        pa_deg = rotator_position - instrument_angle + zp_offset
    elseif rotator_mode == "stationary"
        # TODO: Handle case where the instrument rotator is stationary.
        return NaN, [NaN]
    else
        throw(ArgumentError("Unknown rotator mode " * rotator_mode))
    end

    # Keck rotator bug.
            # parang = headers["PARANG"] # Degrees
    # This does not appear to actually work
    diff = 0.0
    # if haskey(headers, "ROTNORTH")
    #     pa_deg_idl = -headers["ROTNORTH"]
    #     # diff += (pa_deg_idl - pa_deg)
    #     # println(diff)
    #     @info "Using ROTNORTH header from IDL pipeline" maxlog=1
    # end

    # Now calculate smear

    # Get info for PA smearing calculation.
    # epochobj = headers["DATE-OBS"]
    # name = headers["TARGNAME"]
    expref = headers["ITIME"]
    coaddref = headers["COADDS"]
    sampref = headers["SAMPMODE"]
    msrref = headers["MULTISAM"]
    xdimref = headers["NAXIS1"]
    # ydimref = headers["NAXIS2"]
    dec = float_or_parse_hexages(headers["DEC"]) + headers["DECOFF"]

    if haskey(headers, "TOTEXP")
        totexp = headers["TOTEXP"]
    else
        # Calculate total time of exposure (integration + readout).
        if sampref == 2
            totexp = (expref + 0.18 * (xdimref / 1024.0)^2) * coaddref
        end
        if sampref == 3
            totexp =
                (expref + (msrref - 1) * 0.18 * (xdimref / 1024.0)^2) * coaddref
        end
    end
    # tinteg = totexp # [seconds]
    totexp = totexp / 3600.0 # [hours]

    # Get hour angle at start of exposure.
    tmpahinit = float_or_parse_hexages(headers["HA"]) # [deg]
    ahobs = 24.0 * tmpahinit / 360.0 # [hours]

    if totexp * 3600 > 1 # If greater than 1 second...
        # Estimate vertical position angle at each second of the exposure.
        vp = Float64[]
        vpref = 0.0
        for j in 0:(3600*totexp-1)
            ahtmp = ahobs + (j + 1.0 + 0.001) / 3600.0 # hours
            # TODO: par_angle and observatory_latitude
            push!(vp, par_angle(ahtmp, dec, observatory_lat))
            if j == 0
                vpref = vp[1]
            end
        end

        # Handle case where PA crosses 0 <--> 360.
        vp[vp.<0] .+= 360
        vp[vp.>360.0] .+= 360

        if vpref < 0
            vpref += 360
        end
        if vpref > 360
            vpref -= 360
        end

        # TODO: This is some crazy code... Should use use meandegrees()
        # that uses atan() to avoid this.
        # Check that images near PA=0 are handled correctly.
        if any(vp .> 350) && any(vp .< 10)
            vp[vp.>350] .-= 360
        end
        vpmean = mean(angle for angle = vp if isfinite(angle))

        if vpmean < 60 && vpref > 350
            vpmean += 360
            vp .+= 360
        end
        pa_deg_mean = pa_deg + (vpmean - vpref)

        # angle_start = pa_deg
        # angle_smear = vpmean - vpref
        angle_mean = pa_deg_mean
        return angle_mean+diff, vp.+diff
    else # Total exposure less than one second - treat as no smear
        return pa_deg+diff, [pa_deg+diff]
    end
end

"""
Compute the parallactic angle, given hour angle (HA [hours]),
declination (dec [deg]), and latitude (lat [deg]).  Returns
parallactic angle in [deg].
Source: pyKLIP
"""
function par_angle(HA, dec, lat)

    HA_rad = deg2rad(HA * 15.0) # [hours] -> [rad]
    dec_rad = deg2rad(dec)   # [deg] -> [rad]
    lat_rad = deg2rad(lat)   # [deg] -> [rad]

    parallang =
        -atan(
            -sin(HA_rad),  # [rad]
            cos(dec_rad) * tan(lat_rad) - sin(dec_rad) * cos(HA_rad),
        )

    return rad2deg(parallang) # [deg]
end

function load_sequences(sequence_obslog)
    sequences = Dict{String, Any}()
    for key in keys(sequence_obslog)
        if !(key in ["data_folder", "subfolder", "date"])
            sequences[key] = load_frames(sequence_obslog, key)
        end
    end
    return sequences
end

end
